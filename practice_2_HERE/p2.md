# Practice 1: Environment Setup and Basic Work with LLVM IR

**Goal**: Improve simple compiler from the first lesson with introduction of lexer and extending supported syntax.


## Task 1: Implement a Lexer as a State Machine (2 points)
**IMPORTANT** Ensure that the main file with compiler is called `compiler.*`. The compiler binary or script should take two arguments e.g. `./compiler path/to/input.txt path/to/output.ll`. You can also include a simple script `full_compiler.sh` to compile and link binary with one call. Also note that you can use `lli` for debugging as an interpreter for generated IR LLVM.

We will use the programming language and simple compiler you implemented for the **Practice 1** as a base for this task but you should take into account the changes to the syntax from **Task 2** of this practice.

Your goal is to implement a lexer algorithm that will scan the source code byte by byte to find a valid tokens using state machine approach. For example, we have a sequence
`   i32 mut x{ 10 }\n    var t`
We should have an initial state which should analyse bytes based on their class. In this case it will scan 3 spaces one by one and will just ignore them, then `i` symbol will be found - it means that some token most likely related to identifier has just started, so we should memorise this symbol and switch our state machine into the state for identifiers search. This new state will scan the next char `3` which looks as the next symmbol of identifier as it is alphanumeric, so we have `i3` to memorise, and on the next step we will get `2` and `i32`. When we will scan the next symbol we will get a space ` ` which in this case signal termination of the previous token. We got `i32` which is a built-in type name in new syntax(see Task 2) so we can categorise the token as built-in type keyword, append it to the list of parsed tokens and return to the initial state. Initial state will continue scanning and it will find `m` which signals about new identifier, so identifier state should be used for further scan. Note that on the next step we will parse `x` and after switch to identifier state we will find `{` which will require creation of another type of token in addition to identifier `x`. When we scan `1`, we will expect number constant so we can use another state in the state machine to handle further sequence of bytes. As a result we should get something like
`(i32, keyword, typename), (mut, keyword, specifier), (x, identifier, name), ({, block, start), (10, constant, numeric), (}, block, end), (\n, endline, -), (var, identifier, name), (t, identifier, name)`
You can use a single vector to store the tockens or vector of vectors to represent split into the lines which is reasonable with our syntax.
Then you can go through the tokens and check whether they form a valid constructions and if so generate IR LLVM or report compilation error.


## Task 2: Extend Language Syntax (1 point)
Let's make the following changes into the syntax of our language:
- Names of the variables should start from
- Introduce `i32` type name;
- All variables are const by default;
- `mut` keyword should be used after the type name to declare a mutable variable;
- If variable is not marked as `mut`, we can't assign value to it.
- All variables should be defined during declaration with a new syntax e.g. constant or variable or simple expression inside `{}` e.g. `{10}`, `{x}`, `{y+10}`, `{x + y}` and so on.
Therefore the following code of declaration is valid:
```
i32 x{0}
i32 mut y{10}
i32 z{2+5}
i32 mut t { x + 10 }
```
- Allow to exit/return constants at the end of the program, not only variables.

Note: all other rules should be as they were before e.g. we can assign only constant or variable or result of one of the three operations `+`, `-`, `*`; each instruction should be placed on its own line, no extra words should be present and so on.

