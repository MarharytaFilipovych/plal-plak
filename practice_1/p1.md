# Practice 1: Environment Setup and Basic Work with LLVM IR

**Goal**: Ensure students have a working environment and can write and compile simple programs using LLVM by translating to LLVM Intermediate Representation (IR).

**Knowledge Base**: LLVM IR is an assembly-like language that provides a unified way to represent program logic. LLVM can then compile and optimize this IR for various platforms. Instead of building an entire compiler, you only need to convert your language's syntax into IR, and LLVM handles the rest.

## Task 1: Install Environment (1 point)
Set up a Linux environment using tools like Multipass, Lima, Docker, or WSL. Inside this environment, install the `llvm` and `clang` packages.

### Steps:
1. Create a file named `test.ll` with the following content:
   ```llvm
   define i32 @main() {
     %add_tmp = add i32 3, 5
     ret i32 %add_tmp
   }
   ```
2. Compile the IR to an object file:
   ```bash
   llc -filetype=obj test.ll -o test.o
   ```
3. Link the object file to create an executable:
   ```bash
   clang test.o -o test
   ```
4. Run the executable and check the return code:
   ```bash
   ./test
   echo $?
   ```

**Expected Outcome**: The program runs and returns `8` (the result of `3 + 5`).

## Task 2: Write a Simple Compiler (2 points)
Using the [LLVM IR Language Reference](https://llvm.org/docs/LangRef.html), create a script or program that converts a simple language (defined in a `.txt` file) into LLVM IR. The simple language has the following rules:
- All variables are 32-bit integers (`i32`).
- Variable declaration: Use `var x` (one variable per line, no other words).
- Variable names must be valid (alphanumeric, no spaces, no reserved keywords).
- Variables must be declared before use.
- Assignments can be:
  - A constant, e.g., `x = 0` (spaces around `=` are optional).
  - The result of operations (`+`, `-`, `*`) on variables or constants, e.g., `x = y + 3`, `y = t * z`, `i = 2 - someVar`.
- The program ends with `return someVarName`, which triggers the output: `Program exit with result <value of someVarName>`.

### Example Input (`input.txt`):
```
var x
var y
x = 5
y = x + 3
return y
```

### Expected Behavior:
- Convert `input.txt` to LLVM IR.
- Compile and run the IR to output: `Program exit with result 8`.

### Guidelines:
- Use a scripting or programming language of your choice to parse the input and generate LLVM IR.
- Ensure the generated IR is valid and follows the structure in the [LLVM IR Language Reference](https://llvm.org/docs/LangRef.html).
- For advanced exploration, you may refer to the Kaleidoscope language (covered later in the course), but focus on the simple language described above for this task.
- Test your compiler by compiling the generated IR (as in Task 1) and verifying the output. Note, that using of functions like printf in this case will require additional flags for position independent code generation
```
llc -filetype=obj -relocation-model=pic test.ll -o test.o
clang -fPIE test.o -o test
```

Sample code:
```
declare i32 @printf(i8*, ...)

@print_format = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1

define void @printResult(i32 %val) {
  %fmt_ptr = getelementptr inbounds [4 x i8], [4 x i8]* @print_format, i32 0, i32 0
  call i32 (i8*, ...) @printf(i8* %fmt_ptr, i32 %val)
  ret void
}

define i32 @main() {
  %add_tmp = add i32 3, 5
  call void @printResult(i32 %add_tmp)
  ret i32 0

}
```

**Deliverables**:
- A working Linux environment with `llvm` and `clang`.
- A script or program that converts the described language into LLVM IR.
- Test cases demonstrating correct IR generation and execution.
